# SoftwareEval-Backends

This library contains trace-based backends for software evaluation with instruction set simulators (ISS). The library mainly contains:

- Channel interfaces, acting as interfaces between the ISS and the backends
- PerformanceEstimator backends, reporting an estimate on the required number of clock cycles to execute the target software
- Printer backends, dumping trace-values observed over the channel to files or the terminal

An example of a library using SoftwareEval-Backends is the [SoftwareEvalLib](https://github.com/tum-ei-eda/SoftwareEvalLib) for the ETISS simulator.

The SoftwareEval-Backends library contains backends for different core variants. The majority of these files can be automatically generated using [M2ISAR-Perf](https://github.com/tum-ei-eda/M2-ISA-R-Perf) (performance estimators) and M2ISAR (channels and printers).

## Usage

### Setup

To use the backends include the following header-files in your code:

```C++
#include "softwareEval-backends"/Factory.h"
#include "softwareEval-backends"/Channel.h"
#include "softwareEval-backends"/Backend.h"
```

Create a factory object. Use it to receive pointers to a channel and the appropriate backends (performance estimator and/or printer) for the desired variant:

```C++
SwEvalBackens::Factory backendFactory;

// replace your_variant_name with desired name, e.g.: CV32E40P
int backendHandle = backendFactory.getVariantHandle("your_variant_name"); // Return value < 0 if variant does not exist

Channel* channel_ptr = backendFactory.getChannel(backendHandle) // returns nullptr if channel not found
Backend* estimator_ptr = backendFactory.getPerformanceEstimator(backendHandle) // returns nullptr if estimator not found
Backend* tracePrinter_ptr = backendFactory.getTracePrinter(backendHandle) // returns nullptr if printer not found
```

Connect the channel to the backends. Remember to also connect the channel to the used ISS (or its monitor):

```C++
estimator_ptr->connectChannel(channel_ptr);
tracePrinter_ptr->connectChannel(channel_ptr);
```

Initialize the backends. Optionally, the backends can be enabled to generate a trace and dump it to file(s):

```C++
// replace path_to_out_dir with the desired path
estimator_ptr->activateStreamToFile("timing_trace", "path_to_out_dir", ".csv", 0x1000000); // Optional, will slow down performance simulation
tracePrinter_ptr->activateStreamToFile("timing_trace", "path_to_out_dir", ".csv", 0x1000000); // Optional, but printer without active stream is useless

estimator_ptr->initialize();
tracePrinter_ptr->initialize();
```

### During Simulation

During simulation, trigger the backends to read and process data from channel. Note it is the ISS's (or it's monitor's) responsebility to avoid overflow of the channel:

```C++
estimator_ptr->execute();
tracePrinter_ptr->execute();
```

### End of Simulation

At the end of the simulation, call the backend's `finalize` function:
```C++
estimator_ptr->finalize();
tracePrinter_ptr->finalize();
```

## Update

You can update or add backend variants by deploying appropriate C++ source and header files. These files are typically generated by M2ISAR and M2ISAR-Perf (see above). You can automatically deploy these files by calling:

    $ ./scripts/deploy_backend.py <variantName> file1,file2,...,fileN

Note:

- Supported suffixes for files are ".cpp" (src) and ".h" (header)
- The script will update "CMakeLists" files
- If files allready exist, they will be over-written.
- If variant was not present before, the script will add the new variant to "Factory.cpp" and "Factory.h" files, by over-writing them